---
title: 小知识
categories: 文章
tags: 收集优质题目/面试题
---

# Java

## Java集合类框架的基本接口有哪些？

```
java集合中分为：value(Conllection)、key-value(Map)两种存储结构
	|存储value有分为：List、Set、Queue
       List：有序，可重复
       Set：无序，不可重复。根据equals和hashcode进行判断
       Queue：队列
       
    |存储key-value为map
    	key唯一且不可重复。value可重复
```

## Java中的HashMap的底层原理实现、工作原理？

```
HashMap底层是哈希表，是基于hash算法实现的。hashmap通过put(key,value)添加，通过get(key)获取。
当传入key时，hashmap会调用key.hashcode()方法计算hash值，根据hash值将value保存在bucket里。当计算出现相同的key值，称之为hash冲突。
将hash冲突的value进行euqals()方法判断，如果为true，将相同key的 新value 替换 原有的value值。如果为false，hashmap做法是用链表和红黑树存储相同hash值的value。当hash值<=8个时使用链表，当超过8个时，先尝试扩容来减少链表长度，如果数组容量已将>=64，则使用红黑树
```

## **JDK1.7 和 JDK1.8中HashMap为什么线程不安全？**  

详细内容：地址	"https://blog.csdn.net/swpu_ocean/article/details/88917958"

```
HashMap的线程不安全：JDK1.7中会出现 死循环、数据丢失、数据覆盖。JDK1.8中解决了前面两个，但仍会有数据覆盖的问题

JDK1.7中线程不安全主要发生在扩容函数中，即根源在transfer函数中。
Hash扩容操作：重新定义每个桶(bucket)的下标，并采用【头插法】将元素迁移到新数组中（头插法：会将链表的顺序翻转，这个是形成死循环的关键）

JDK1.8中线程不安全：根据JDK1.7中出现的问题，在JDK1.8已经很好的解决了，JDK1.8的源码已经找不到transfer函数，因为JDK1.8直接在resize函数中完成了数据迁移。JDK1.8在进行元素插入时使用的是【尾插法】

HashMap的线程不安全主要体现在下面两个方面：
    1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。
    2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。
```

## Java内存模型 和 Java内存结构

```
Java内存结构(运行时数据区域)：堆、栈、方法区

Java内存模型：这是一种 符合计算机内存模型规范，屏蔽了各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致性效果的 一种机制以及规范。
目的，是解决由于多线程通过共享内容进行通讯的时候存在的一些原子性、可见性以及有序性的问题

注：原子性，如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行(回滚事务)
```

## 缓存击穿/缓存穿透/缓存雪崩

```
缓存穿透：
	指的是缓存服务器中没有要查的数据，数据库中也没有，导致业务系统每次都会绕过缓存服务器，去查询下游的数据库，缓存服务器就失去了应有的作用
	例子：XXX去商店买某东西,门店没有货，于是要求店员咨询厂家,发现厂家也没有货了，这人就离开了。过一会yyy也来买同样的东西，店员又重复的咨询厂家。如此反复...
	
缓存击穿
	指的是当某一个 key 缓存过期的时候，大量并发的请求来同时访问这个 key，瞬间穿透缓存服务器直接访问数据库，导致数据库过载的情况
	例子：某东西一夜之间火了,刚好门店卖完了。很多都来商店里购买，那么就会有很多门店以及很多店员同时咨询厂家

缓存雪崩
	指的是当大量的缓存同时过期，或者缓存服务器宕机了，所有的请求直接访问到数据库，造成数据库过载很高，影响性能甚至宕机的情况
	例子：门店大部分的东西都卖没了，而又有很多人来买，这个时候又有很多门店同时打电话咨询厂家，或者会有很多客户自己打电话咨询厂家
```

